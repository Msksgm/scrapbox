# 0911\_「OAuth 徹底入門 セキュアな認可システムを適用するための原則と実践」 読書 継続 262 日

「OAuth 徹底入門 セキュアな認可システムを適用するための原則と実践」 を読んでいます。

脆弱性の章を読んでいます。

## よく狙われる OAuth トークンの脆弱性の脆弱性

### Bearer トークンとは何か

OAUth2.0 の仕様を設計している際に、OAuth1.0 の仕様にあった独自の署名の仕組みを取り除き、その処理を TLS のような異なるパーティー間でのやりとりを安全にするトランスポート層での仕組みを任せた。  
その結果、様々な種類のトークンを適用できるようになった。

Beare トークンはセキュリティを担保する仕組みで使うアイテム。
定義されていることは、トークンを尚友する（Bearer：持参人）が誰であれ、そのトークンをリソースのアクセスのために使える。  
トークンのようなアイテムを持っていればサービスへのアクセスが許可されるようになり、その際に、誰がそのアイテムを使っているのかについて気にすることはない。

OAuth1.0 の独自の署名では、検証においてクライアント開発者とサーバー開発者の両方に大きな負担を与えた。  
また、TLS の仕組みが不要になることはなかった。  
そのため、OAuth1.0 から OAuth2.0 に移行する際に、シンプルな仕組みである、Bearer トークンが採用された。

### Bearer トークンの使用に関するリスクと考慮点

- トークンの偽造（Token Forgenry）
- トークンのリプレイ（Token Replay）
- トークンの流用（Token Redirect）
- トークンからの漏洩（Token Disclosure）

### どのように Bearer トークンを保護するのか

OAuth2.0 認可フレームワークの仕様によると、アクセス・トークンの送信は SSL/TLS のように機密性を端から端まで保てる方法を使って保護されなければならない。  
SSL/TLS とは、コンピュータ・ネットワーク上で安全なコミュニケーションを提供するために設計された暗号化プロトコル。２つのパーティー間のやりとりを保護するもの。

- 送信されるデータの暗号化に非対称鍵暗号（共通鍵暗号）が使われているため、その接続はプライベートなものになる
- 送信される各メッセージにはメッセージ認証コード（Message Authentication Code: MAC）を使ったメッセージの生合成チェックが含まれているので、その接続は信頼できるものになる

TLS で保護されていなければ OAuth の Bearer トークンを安全に使うことはできず、TLS はトークンの運搬時において、そのトークンを保護するための接続の一部とならなければいけない。

#### クライアント側での保護

アクセス・トークンのスコープを最小限にする。最小権限によるアプローチは仮にトークンが盗まれても、トークンを使って行えることを最小限にする。

アクセス・トークンを一時的なメモリーに格納してリポジトリへのインジェクションによる攻撃を最小限に抑える。

#### 認可サーバーでの保護

トークンの検証に JWT を使う。

認可サーバーがアクセス・トークンをテキストではなくハッシュ値にして格納する。  
仮に盗まれたとしても、漏洩したデータを使って攻撃者ができることはない。

アクセス・トークンの生存時間を短くする。  
リフレッシュ・トークンによってさらに短くする。

システムのいたるところで、安全な監視とログ出力を行う。

#### 保護対象リソースでの保護

まず、認可サーバーと同じような対策をとる。

リソースのエンドポイントはトークンのスコープを限定するように設計する。

リソース・サーバーはトークンを適切に検証する。  
何にでもできるような特別なアクセス・トークンの使用を避ける。

### 認可コード

認可コードを使った付与方式の最も大きなメリットは、アクセス・トークンをリソース所有者のユーザー・エージェントに渡すことなく、そしてリソース所有者を含むほかの構成要素にそのトークンが見られることなく、そのトークンを直接クライアントに送信できるようにしていること。しかし、精巧な攻撃によって認可コードは奪われてしまう。

認可コードは、クライアントがクライアント・シークレットを持っていて、それを使ってクライアント認証する場合は、それ自体で有益にはならない。しかし、ネイティブ・アプリケーションではクライアント・シークレットに対する特有の問題をもっている。

それらの、問題点を踏まえて、OAuth のリーキング・グループは PKCE（Proof Key for Code Exchange）を追加の仕様として公開した。

#### PKCE（Proof Key for Code Exchange）

認可コードによる付与方式を使っている公開クライアントは認可コード横取り攻撃の対象によくされる。  
PKCE の仕様は認可コードのリクエストとそれに続くトークンのリクエストを安全に結びつけることで、この攻撃からクライアントを保護するために導入されたもの。

PKCE を機能させる方法

- クライアントは code_verifier と名付けられたシークレットを生成して記録する
- クライアントは code_verifier をもと code_challenge を算出する。この code_challenge は code_verifir そのものなのか code_verifier の SHA-256 のハッシュ値のどちらかになる（よく後者が使われる）
- クライアントは code_challenge と任意の code_challenge_method を通常の認可リクエストのパラメータとともに認可サーバーに送る
- 認可サーバーは通常と変わらず応答するが、通常と異なることとして code_challenge と（もし提示されていれば）code_challenge_method を記録する。これらは認可サーバーによって発行される認可コードと関連づけられる
- クライアントは認可コードを受け取ると、いつものようにトークンを取得するためのリクエストを作成し、そこに先ほど生成した code_verifier のシークレットを含める
- サーバーは code_challenge を再び算出し、もとの値と一致するのかをチェックする。もし、一致しない場合はエラーのレスポンスを返し、一致する場合は通常どおり処理を続ける

### まとめ

- アクセス・トークンの送信は TLS のような安全なトランスポート層の仕組みを使って保護されなければならない
- クライアントは必要最低限の情報のみを問い合わせるべきである（保守的にスコープを使うようにする）
- 認可サーバーではアクセス・トークンを平文（Plain Text）ではなくハッシュ値にして格納すべきである
- 認可サーバーではアクセス・トークンの有効期間を短くし、たとえば、ひとつのアクセス・トークンが漏洩したとしても、そのことに対するリスクを最小になるように対策すべきである
- リソース・サーバーはアクセス・トークンを一時的なメモリーに保持すべきである
- 認可コードの安全性を高めるために PKCE が使われることがある
