# 0211\_「失敗から学ぶ RDB の正しい歩き方」 読書 継続 416 日

## 第 12 章 監視されないデータベース

ミドルウェアの監視の種類

1. サービス（プロセス）の死活監視
2. 特定条件のチェック監視
3. 時系列データをもとにしたメトリックス監視

RDBMS の何をモニタリングするべきか

OS 側

- ディスク I/O
- ネットワークトラフィック
- CPU 利用率
- メモリ利用率

RDBMS 側

- SELECT/INSERT/UPDATE/DELETE などの SQL の実行量
- 実際に読み込まれているレコードの量
- インデックスヒット率
- デッドロックの可否
- テンポラリファイルの作成の有無
- ロックの量と時間

## 第 13 章 知らないロック

主なロックのレベル

- 排他ロック
- 共有ロック

主なロックの粒度

- 表ロック
- 行ロック

## 第 14 章 ロックの功罪

トランザクションと ACID

- Atomicity
- Consistency
- Isolation
- Ocurability

トランザクション分離レベル

1. read uncommited すべて発生する
2. read commited ダーティーリードのみ発生しない
3. compatibel read ダーティーリード、ファジーリードが発生しない
4. serializable すべて発生しない

- ダーティーリード
  - ほかのトランザクションから自分のコミットしていない変更内容が見えてしまう現象
- ファジーリード
  - ノンリピータブルリード
  - ほかのトランザクションのコミットしていないデータはみえない
  - トランザクション中にほかのトランザクションがコミットした変更が見えてしまう
  - 不正後はおきないが、並列処理のときに意識する必要がある
  - PostgreSQL では発生する
- ファントムリード
  - ほかのトランザクションがコミットした追加・削除が見えてしまう現象
- ロストアップデート
  - 複数のトランザクションで更新が並列に行われた場合、あとに実行されたトランザクションで結果が上書きされる現象

## 第 15 章 簡単過ぎる不整合

非正規化したい場面

- テーブルを作って正規化するのが面倒なとき
- 外部キー制約によってデッドロックなどが発生しているとき
- 正規化によって JOIN のコストがたかくなり、パフォーマンスに問題が出ているとき

アンチパターンを生まないために

- CHECK 制約
- ENUM 型

「強過ぎる制約」の問題になるので気を付けること

## 第 16 章 キャッシュ中毒

しっかり検討をしてキャッシュの利用をする

キャッシュのデメリット

- キャッシュしたデータの状態を意識することが難しく、参照時にどの状態なのかコード側からは直感的に把握しにくい
  - キャッシュともとデータの整合性を合わせる必要がある
  - キャッシュの生存期間を決める必要がある
  - キャッシュを正しく読み取る必要がある
- キャッシュしたデータのデバッグが難しく、どのデータがキャッシュされているかを把握しづらい
  - 参照されたタイミングのキャッシュがどのデータか把握か難しい
  - どのデータがキャッシュされたか把握が難しい
  - どこまでキャッシュされているのかの把握が難しい

クエリキャッシュ

デメリット

- 実行されたクエリの結果が、キャッシュなのか最新情報なのかわからない
- テーブルが更新されるとキャッシュとして不適切なため、クエリキャッシュはクリアされる
- まったく同じクエリでなければキャッシュされない

マテリアライズド・ビューとサマリーテブル

アプリケーションキャッシュ
