# 0212\_「失敗から学ぶ RDB の正しい歩き方」 読書 継続 417 日

## 第 17 章 複雑なクエリ

要点

1. 複雑なクエリが生まれた理由
2. 代替案があるかどうか

複雑なクエリが生まれた理由

- 無知ゆえの剛腕
  - スキル不足に起因した、力技による解決としての複雑なクエリ
- 腐ったテーブルの腐ったクエリ
  - テーブル設計に問題を抱えており、目的を達成するため結果的に複雑になったクエリ

アンチパターンを生まないために

パーツで読み解く

1. FROM
2. ON
3. JOIN
4. WHERE
5. GROUP BY
6. HAVING
7. SELECT
8. DISTINCT
9. ORDER BY
10. LIMIT

意図と背景を読み解く

- 不要なパーツ、ボトルネックになっているパーツを明確化することで、リファクタリングできる
- 複雑度の高いパーツは、実行結果を加工する

アンチパターンのポイント

複雑なクエリとひとくくりにするのではなく、裏にある意図や背景を考えること

## 第 18 章 ノーチェンジ・コンフィグ

正しくないコンフィグは、パフォーマンス、セキュリティなど多くの場所に影響を与える

コンフィグを知る

コンフィグの役割

1. パフォーマンス
2. セキュリティ
3. RDBMS の振る舞い

コンフィグを管理する

アンチパターンを生まないために

- Infrastracure as Code を実践する
- バージョンごとのコンフィグの違いを知る
- コンフィグのチェックツール PostgresQL->PgTune、MySQL->MySQL Tuner を使う
- Database as a Service（DBaaS）を使って、管理を自分たちでおこない

アンチパターンのポイント

コンフィグは属人化しやすいので、IaC を体現していく

## 第 19 章 塩漬けのバージョン

5 年 10 年と寿命の長い RDBMS だからこそ、塩漬けになったバージョン固定のシステムが存在する
パフォーマンスの向上や既知の問題を解決できることも少なくないので普段から意識する

マイナーバージョンアップとメジャーバージョンアップ

- マイナーバージョンアップ
  - バグ対応やセキュリティアップデート
  - 難易度が低い
- メジャーバージョンアップ
  - 機能追加や機能改善のアップデート
  - 難易度が高い

バージョンアップをする動機

- 現在利用するバージョンのサポートが切れるため
- 現在利用しているバージョンを利用することによる管理コストの増加
- 新機能を利用したい
- パフォーマンスを向上させたい

固定する理由とデメリット

- 停止時間とメンテナンス時間
- アプリケーションへの影響

アンチパターンを生まないために

1. バージョンアップ方法の決定
2. コンフィグの確認
3. リハーサル
4. バージョンアップ作業

バージョンアップ方法の決定は 4 つある

- ダンプ・リストア
- 専用ツール
- レプリケーション
- アプリケーションの二重書き込み

バージョンアップする文化を作る

## 第 20 章 フレームワーク依存症

「マジックビーンズ」

フレームワークへの依存に加えて、スロークエリの発行元を追うことの難しさがある
アプリケーションの生産性自体は向上することが多いため、ビジネス的な判断では一概に間違っているとはいえない

- View と Model と RDBMS
- マジックビーンズ
- テーブル設計が View に依存する
- テーブル設計がライブラリに依存する

アンチパターンを生まないために

- 独自型への制約
- 漏れのある抽象化
- フレームワークとの上手な付き合い方

アンチパターンのポイント
フレームワークに依存するトレードオフを常に意識する
