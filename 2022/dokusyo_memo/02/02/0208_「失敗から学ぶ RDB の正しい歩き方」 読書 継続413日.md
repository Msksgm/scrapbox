# 0208\_「失敗から学ぶ RDB の正しい歩き方」 読書 継続 413 日

## 第 1 章　データベースの迷宮

例

- memo1、memo2、memo3...と無限に続く、何が入っているのかわからないカラム
- タイプミス
- 値の意味がわからないカラム
- 外部キー制約がなく、リレーションシップがまったくわからないテーブル

何が問題か

- 不適切な名前では、データベースのテーブルの関連性や意図が理解できない
- リレーショナルモデルに基づいた設計をしていないと、既存の便利なツールを利用できない
- 保存されたデータが正しいかどうかが判断できない
- どのようなデータを保存し、どのようなデータを取り出せばいいかわからない

動くものを作るといに適切に作る

- 命名ミスは初期段階で対処
- 今後を想定した命名
- 技術的負債とは、やむをえず将来に課題が残る方法を採用してしまったこと。DB はアプリより寿命が長いので負債を返済していく必要がある

アンチパターンのポイント

「割れ窓理論」と同じで、「データベースのオブジェクトに不適切な名前で放置すると、誰も注意を払っていないという象徴になり、やがてデータベースそのものもすべて壊される」

わかりづらい設計や名前はデータベースの破綻の始まり

## 第 2 章 失われた事実

不用意に更新すると不可逆な変化がおきて、以下のような問題が発生する

1. 過去の事実（値）が失われる
2. 過去の事実（過程）が失われる

過去の事実は非常時に必要になる

アンチパターンを生まないためには

履歴を保存する、有効期限を保つ、打ち消しのレコードを持つ。

「履歴の保存」はトレードオフ

- レコードの保存量が増えるためテーブルサイズが増える
- 集計が単純な主キー検索ではなくなるため、テーブルサイズが肥大化した際に検索速度が劣化する

アンチパターンのポイント

- 払い戻しなどの取り消し処理に対応できるか
- 配送状況などステータス変化を追えるか
- トラブル対応時、欲しい情報が失われていないか

あえて履歴を持たない時の対策

- 遅延レプリケーション（1 日遅れのスレープ DB を作ったり、2 時間遅れのスレープ DB を作ったりする機能のこと。物理コストが高い）を使う
- アプリケーションログとして Elasticsearch などの分析ツールに保存する

## 第 3 章 やりすぎた JOIN

- JOIN に対する不理解
- 多段 JOIN と不要な JOIN
- JOIN の内部表に INDEX がない

JOIN の問題点

INDEX がないと指数関数的に計算量が増える

JOIN のアルゴリズムの種類

- Nested Loop Join (NLJ)
  - 1 行ずつループして処理をする
- Hash Join
  - 一度に全件を読みこんで処理をする
  - 小さい表を全件読み取って Hash 表を作成、大きい表の結合列を Hash 表の値と比較して結合、両テーブルを 1 回ずつ全件読み取り
- Sort Merge Join
  - 全件をソートして上から順に比較する
  - 2 つの表の結合キーでソート、ソート後は上から順に値を比較して結合

アンチパターンのポイント

- JOIN は必要最低限
- INDEX を適切に活用する
- JOIN するテーブルは小さくしてから JOIN する
- 複雑なクエリになった場合は View を活用する

## 第 4 章 効かない INDEX

INDEX とはテーブルからデータを高速に取り出すための RDBMS のしくみ

BTree INDEX が一般的に使われている

設定した INDEX が効かない（使われない）ケース

- 検索結果が多い、全体の件数が少ない
- 条件にその列を使っていない（関数）
- カーディナリティの低い列に対する検索（性別）
- あいまいな検索（前方一致以外の LIKE）
- 統計情報と実際のテーブルで乖離がある場合

INDEX を利用するかどうかは、クエリ実行時にオプティマイザが判断して決めている
定期的にサンプリングをおこなうことで、きめている

乖離する理由

1. サンプリングの前に大量のデータ更新が行われた
2. サンプリングを偏ったデータで収集した

このような場合には、統計情報の更新を行う
好ましくない場合は固定をする

アンチパターンのポイント

- INDEX（とくに BTree INDEX）の特性をしっかり把握して適切な INDEX を設定する
- INDEX を利用するクエリを実行する
- INDEX を活用できるテーブル設計をする
- スロークエリログやデータの状態などをしっかりとモニタリングする
